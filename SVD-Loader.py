# Load specified SVD and generate peripheral memory maps & structures.
#@author Thomas Roth thomas.roth@leveldown.de
#@category leveldown security
#@keybinding
#@menupath
#@toolbar

# More information:
# https://leveldown.de/blog/svd-loader/
# License: GPLv3

from cmsis_svd.parser import SVDParser
from ghidra.program.model.data import Structure, StructureDataType, UnsignedIntegerDataType, DataTypeConflictHandler
from ghidra.program.model.data import UnsignedShortDataType, ByteDataType, UnsignedLongLongDataType
from ghidra.program.model.mem import MemoryBlockType
from ghidra.program.model.address import AddressFactory
from ghidra.program.model.symbol import SourceType
from ghidra.program.model.mem import MemoryConflictException
import traceback

class MiniRegister(object):
	def __init__(self, reg):
		self.name = reg.name
		self._size = reg._size
		self.description = reg.description
		self.address_offset = reg.address_offset

class MiniPeripheral(object):
	def __init__(self, periph):
		self.name = periph.name
		self.base_address = periph.base_address
		self.registers = []
		for register in periph.registers:
			self.registers.append(MiniRegister(register))

	def add_register(self, reg):
		self.registers.append(reg)

	# new_base_addr should **always be lower**
	def displace(self, new_base_addr):
		assert(new_base_addr <= self.base_address)
		offset = new_base_addr - self.base_address
		self.base_address = new_base_addr
		if offset != 0:
			for register in self.registers:
				register.address_offset += offset

class MemoryRegion:
	def __init__(self, name, start, end):
		self.name = name
		self.start = start
		self.end = end

	def length(self):
		return self.end - self.start

def reduce_memory_regions(regions):
	for i in range(len(regions)):
		r1 = regions[i]
		for j in range(len(regions)):
			r2 = regions[j]
			# Skip self
			if i == j:
				continue
			if r1.end < r2.start:
				continue
			if r2.end < r1.start:
				continue

			# We are overlapping, generate larger area and call
			# reduce_memory_regions again.
			regions[i].start = min(r1.start, r2.start)
			regions[i].end = max(r1.end, r2.end)
			regions[i].name = r1.name + "_" + r2.name
			regions.remove(regions[j])
			return reduce_memory_regions(regions)
	return regions

def calculate_peripheral_size(peripheral):
	size = 0
	for register in peripheral.registers:
		size = max(size, register.address_offset + register._size/8)
	return size

svd_file = askFile("Choose SVD file", "Load SVD File")

print("Loading SVD file...")
parser = SVDParser.for_xml_file(str(svd_file))
print("\tDone!")

# CM0, CM4, etc
cpu_type = parser.get_device().cpu.name
# little/big
cpu_endian = parser.get_device().cpu.endian

# Not all SVDs contain these fields
if cpu_type and not cpu_type.startswith("CM"):
	print("Currently only Cortex-M CPUs are supported.")
	print("Supplied CPU type was: " + cpu_type)
	sys.exit(1)

if cpu_endian and cpu_endian != "little":
	print("Currently only little endian CPUs are supported.")
	print("Supplied CPU endian was: " + cpu_endian)
	sys.exit(1)

# Get things we need
listing = currentProgram.getListing()
symtbl = currentProgram.getSymbolTable()
dtm = currentProgram.getDataTypeManager()
space = currentProgram.getAddressFactory().getDefaultAddressSpace()

namespace = symtbl.getNamespace("Peripherals", None)
if not namespace:
	namespace = currentProgram.getSymbolTable().createNameSpace(None, "Peripherals", SourceType.ANALYSIS)

peripherals = parser.get_device().peripherals

print("Generating memory regions...")
# First, we need to generate a list of memory regions.
# This is because some SVD files have overlapping peripherals...
memory_regions = []
for peripheral in peripherals:
	start = peripheral.base_address
	length = peripheral.address_block.offset + peripheral.address_block.size
	end = peripheral.base_address + length

	memory_regions.append(MemoryRegion(peripheral.name, start, end))
memory_regions = reduce_memory_regions(memory_regions)

# Create memory blocks:
for r in memory_regions:
	try:
		addr = space.getAddress(r.start)
		length = r.length()

		t = currentProgram.memory.createUninitializedBlock(r.name, addr, length, False)
		t.setRead(True)
		t.setWrite(True)
		t.setExecute(False)
		t.setVolatile(True)
		t.setComment("Generated by SVD-Loader.")
	except:
		print("\tFailed to generate memory block for: " + r.name)
		traceback.print_exc()

print("\tDone!")

def peripherals_overlap(x, y):
	x_start = x.base_address
	x_stop = x_start + calculate_peripheral_size(x)
	y_start = y.base_address
	y_stop = y_start + calculate_peripheral_size(y)
	if x_start == x_stop or y_start == y_stop:
		return False
	return ((x_start < y_stop  and x_stop > y_start) or
			(x_stop  > y_start and y_stop > x_start))


merged_peripherals = []

def merge_or_append(peripheral):
	for merged_peripheral in merged_peripherals:
		if peripherals_overlap(peripheral, merged_peripheral):
			print("Merging " + peripheral.name + " (" + hex(peripheral.base_address) + ") and " + merged_peripheral.name + "(" + hex(merged_peripheral.base_address) + ")")
			merged_peripheral.name += "_" + peripheral.name
			new_base_address = min(merged_peripheral.base_address, peripheral.base_address)
			print("\tDisplacing merged region by " + str(new_base_address - merged_peripheral.base_address))
			merged_peripheral.displace(new_base_address)

			p_reg_offset = peripheral.base_address - new_base_address
			print("\tDisplacing new registers by " + str(p_reg_offset))
			for register in peripheral.registers:
				register = MiniRegister(register)
				register.address_offset += p_reg_offset
				register.name = peripheral.name + "_" + register.name
				merged_peripheral.add_register(register)
				print("\tAdding register " + register.name + " at offset " + str(register.address_offset) + " - new struct size: " + str(calculate_peripheral_size(merged_peripheral)))
			return
	merged_peripherals.append(MiniPeripheral(peripheral))
	return


# First, we want to "merge" peripherals together
for peripheral in peripherals:
	merge_or_append(peripheral)

print("Generating peripherals...")
for peripheral in merged_peripherals:
	print("\t" + peripheral.name)

	if(len(peripheral.registers) == 0):
		print("\t\tNo registers.")
		continue

	try:
		# Iterage registers to get size of peripheral
		# Most SVDs have an address-block that specifies the size, but
		# they are often far too large, leading to issues with overlaps.
		length = calculate_peripheral_size(peripheral)

		# Generate structure for the peripheral
		peripheral_struct = StructureDataType(peripheral.name, length)

		peripheral_start = peripheral.base_address
		peripheral_end = peripheral_start + length

		for register in peripheral.registers:
			r_type = UnsignedIntegerDataType()
			rs = register._size / 8
			if rs == 1:
				r_type = ByteDataType()
			elif rs == 2:
				r_type = UnsignedShortDataType()
			elif rs == 8:
				r_type = UnsignedLongLongDataType()
			print("\t\t" + hex(register.address_offset) + " " + register.name)
			peripheral_struct.replaceAtOffset(register.address_offset, r_type, register._size/8, register.name, register.description)


		addr = space.getAddress(peripheral_start)


		dtm.addDataType(peripheral_struct, DataTypeConflictHandler.REPLACE_HANDLER)

		listing.createData(addr, peripheral_struct, False)

		symtbl.createLabel(addr,
						peripheral.name,
						namespace,
						SourceType.USER_DEFINED );
	except:
		print("\t\tFailed to generate peripheral " + peripheral.name)
		traceback.print_exc()
